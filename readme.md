# OneCore - web framework

<a id="header" />

OneCore - это web фреймворк на движке onescript, созданный для разработки web-приложений любой сложности, используя компонентный подход.

Проект находится в активной разработке. Фреймворк перешёл на onescript 2.0!!!

## Содержание

- [OneCore - web framework](#onecore---web-framework)
  - [Содержание](#содержание)
    - [Установка](#установка)
    - [Структура проекта](#структура-проекта)
    - [Начало работы](#начало-работы)
      - [Создание и регистрация компонента](#создание-и-регистрация-компонента)
      - [Маршрутизация и создание представления (контроллера)](#маршрутизация-и-создание-представления-контроллера)
      - [Запуск и отладка](#запуск-и-отладка)
    - [Шаблонизатор (jinja)](#шаблонизатор-jinja)
    - [Разработка и использование сервисов](#разработка-и-использование-сервисов)
    - [Статические файлы](#статические-файлы)
    - [Перехватчики (Middleware)](#перехватчики-middleware)
    - [Работа с базой данных (ORM)](#работа-с-базой-данных-orm)

[Вернуться к началу](#header)

### Установка

Перед установкой у вас уже должна быть установлена платформа onescript версией не менее 2.0RC5 ветка develop.
Рекомендовано использовать [OVM](https://github.com/oscript-library/ovm) для установки платформы onescript.

1. Скачать ospx файл с релизов (onecore-х.х.х.ospx)
2. Из каталога "simple" корневого каталога репозитория скопируйте содержимое нужного примера в каталог вашего проекта
3. В каталоге вашего проекта разместите скаченный файл библиотеки (onecore-х.х.х.ospx)
4. Выполнить консольную команду: ```opm i -l -f onecore-x.x.x.ospx``` где "x.x.x" версия фрейворка (библиотеки)
5. Дождаться завершения установки зависимостей, далее для запуска используется команда ```oscript main.os``` или отладчик VSCode

<a id="structure" />

### Структура проекта

```md
└── Компонент                  # Каталог компонента, имя каталога соответствует имени компонента
    ├── Модели                 # Модели ORM
    ├── Представления          # Представления данных, они же контроллеры
    ├── Ресурсы                # Статические данные (скрипты, картинки и т. д)
    ├── Сервисы                # Произвольные сервисы, реализующие бизнес логику
    ├── Шаблоны                # HTML шаблоны для шаблонизатора
    └── МодульКомпонента.os    # Скрипт модуля компонента
├── main.os                    # Стартовый скрипт
├── oscript.cfg                # Конфигурационный файл onescript
└── settings.json              # Системный файл с информацией о текущей версии (создаётся автоматически при первом запуске)
```

В корне каталога проекта создаются каталоги компонентов, внутри которых реализуется логика отдельно взятого компонента. При разработке компонентов желательно соблюдать изолированность. В служебных каталогах компонента (Модели, Представления, Ресурсы, Сервисы, Шаблоны) разрешено использовать вложенные каталоги для удобной структуризации логики.

<a id="start" />

### Начало работы

Создание любого приложения на onecore начинается с создания компонента, так как компонент приложения является обособленной функциональной областью, при желании он может быть один, но не советую так поступать.

<a id="components" />

#### Создание и регистрация компонента

Для создания компонента необходимо создать каталог в корне проекта и указать имя каталога в соответствии с именем планируемого компонента, например "Ядро", и создать служебные каталоги компонента (см. Структура проекта), также скрипт МодульКомпонента.os с следующим содержимым:

```bsl
Процедура ПриИнициализацииКомпонента() Экспорт
    // Код, выполняемый при инициализации приложения до его запуска
КонецПроцедуры

Процедура ПриФормированииМаршрутов(Маршруты) Экспорт
    // Код, заполняющий коллекцию маршрутов
КонецПроцедуры

Процедура ПриУстановкеПараметровСеанса(ПарметрыСеанса) Экспорт
    // Код, выполняемый при создании нового сеанса
КонецПроцедуры
```

Для того, чтобы приложение использовало созданный компонент, его необходимо проинициализировать перед запуском приложения в файле main.os:

```bsl
#Использовать onecore

// Подключение компонентов
Приложение.ПодключитьКомпонент("Ядро", "core");

// Инициализация и запуск
Приложение.Инициализировать();
Приложение.Запустить();
```

При выполнении процедуры "Инициализировать", будет вызвана процедура "ПриИнициализацииКомпонента" модуля компонента, в данной процедуре можно выполнять любые действия, например объявить настройки приложения для файла settings.json.

<a id="routing" />

#### Маршрутизация и создание представления (контроллера)

Для того, чтобы ваше приложение принимало запросы, необходимо создать контроллер, контроллеры в onecore называются представлениями, так как они обязаны формировать ответ, в котором данные могут быть представлены в разном формате, например как html, или внешний api для интеграции и т. д.

Для того, чтобы создать контроллер, необходимо в каталоге "Представления" вашего компонента создать скрипт и назвать его так, как далее вы хотите его использовать, например "Приветствие.os" и обязательно заполнить его по шаблону:

```bsl
// Обязательное свойство, без него представление не зарегистрируется
Перем Контекст;

// Служит для выполнения общих действий для всех методов запросов
Процедура Инициализация() Экспорт

КонецПроцедуры

// Обрабатывает запрос с методом GET
Процедура GET() Экспорт
    // Код обработчика запроса
КонецПроцедуры
```

Процедуры обработчиков запросов должны обязательно называться в соответствии с методами HTTP, которые необходимо обработать (GET, POST, PUT, DELETE, HEAD, CONNECT, OPTIONS, PATCH, TRACE), маршрутизатор самостоятельно запустит выполнение нужной процедуры в зависимости от метода поступившего запроса.

Для тестирования сразу напишем код обработчика:

```bsl
Процедура GET() Экспорт
    Контекст.Ответ.ТипКонтента = "html";
    Контекст.Ответ.Записать("<h1>Привет мир!!! Как банально...</h1>");
КонецПроцедуры
```

На данный момент мы имеем объект контроллера, но не понятно, как приложение будет понимать, что запрос адресован именно ему, для этого существует маршрутизация, и указать соответствие адреса с обработчиком мы должны в том же модуле компонента в процедуре "ПриФормированииМаршрутов":

```bsl
Процедура ПриФормированииМаршрутов(Маршруты) Экспорт
    Маршруты.Добавить("/", "Приветствие");
КонецПроцедуры
```

Согласно тому, что мы указали, сервер, при обращении клиента к корневому адресу, будет переадресовывать выполнение в наш контроллер. Процедура "Добавить" принимает в себя 2 параметра, первый - это шаблон адреса, второй - это строковый путь к объекту обработчика запроса через точку, при этом, если бы у нас объект обработчика находился не в корневом каталоге "Представления", а например в каталоге "Тестирование", тогда указание маршрута выглядило бы так ```Маршруты.Добавить("/", "Тестирование.Приветствие");```.

Шаблоны адресов могут содержать параметы, например: ```/users/<Число:Идентификатор>```, что позволяет нам создавать динамические маршруты, сами же параметры части маршрута передаются в качестве параметров в обработчик запроса:

```bsl
Процедура GET(Идентификатор) Экспорт
    Контекст.Ответ.ТипКонтента = "html";
    Контекст.Ответ.Записать("Идентификатор пользователя" + Строка(Идентификатор));
КонецПроцедуры
```

Так же доступен сокращенный способ указания типа контента и кода:

```bsl
&ПараметрыОтвета(ТипСодержимого = "html", КодОтвета = 200)
Процедура GET(Идентификатор) Экспорт
    Контекст.Ответ.Записать("Идентификатор пользователя" + Строка(Идентификатор));
КонецПроцедуры
```

Теперь приложение понимает, куда адресовать запросы.

<a id="debug" />

#### Запуск и отладка

Для запуска приложения достаточно выполнить команду ```oscript main.os```, и перейти по адресу, указанному в консоли. Второй вариант - это настроить отладку, для этого нужно создать файл отладки по инструкции платформы onescript и указать следующее содержимое:

```json
{
    // Используйте IntelliSense, чтобы узнать о возможных атрибутах.
    // Наведите указатель мыши, чтобы просмотреть описания существующих атрибутов.
    // Для получения дополнительной информации посетите: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Приложение",
            "type": "oscript",
            "request": "launch",
            "program": "${workspaceRoot}\/main.os",
            "args": [],
            "cwd": "${workspaceRoot}",
            "env": {},
            "runtimeExecutable": null,
            "runtimeArgs": [],
            "debugPort": 2801
        }
    ]
}
```

Далее запускаем отладку привычным нам способом.

<a id="templateengine" />

### Шаблонизатор (jinja)

Для формирования пользовательского интерфейса фреймворк использует шаблонизатор, другими словами создаётся обычный html файл и в нем уже создаются вкрапления кода onescript, что позволяет реализовывать динамический вывод. При формировании шаблона в него передаётся контекст представления из которого он был вызван, что позволяет использовать его в верстке, например:

```html
<div>"Привет {{Контекст.Данные.Имя}}</div>
```

Так же поддерживаются любые конструкции и методы onescript:

```html
<div>"Сейчас {{ТекущаяДата()}}</div>
```

Как вы могли заметить что подставление данных в html происходит с помощью конструкции ```{{ЗначениеИЛИФункция()}}```

Конструкции языка должы быть заключены в ```{%... %}```, например:

```html
<div>
    {% Если Контекст.Данные.Число > 3 Тогда %}
    Контекст {{Контекст.Данные.Число}} больше 3
    {% Иначе %}
    Контекст {{Контекст.Данные.Число}} меньше 3
    {% КонецЕсли; %}
</div>
```

Тоже самое касается и циклов:

```html
<div>
{% Для Каждого Элемент Из Контекст.Данные.Список Цикл %}
Элемент <h2>{{Элемент}}</h2>
{% КонецЦикла; %}
</div>
```

Реализован механизм вложенности шаблонов с помощью встроенной функции ```Вложить(<путь к шаблону>)```, он позволяет декомпозировать и переиспользовать одни шаблоны в других, например вы создали следующие шаблоны:

```Ядро.Шапка```:

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{Контекст.Данные.Заголовок}}</title>
</head>
<body>
```

```Ядро.Подвал```:

```html
</body>
</html>
```

Теперь их можно использовать, например:
```Ядро.Главная```:

```html
{{ Вложить("Ядро.Шапка") }}
<h1>{{Контекст.Данные.ВыводимыйТекст}}</h1>
{{ Вложить("Ядро.Подвал") }}
```

Для формирования шаблона используется встроенный класс "Шаблонизатор", в него передаётся представление и контекст, далее вызывается функция "Сформировать" с передачей в неё пути к шаблону, она вернет уже свормированный шаблон и его можно будет отправлять в теле ответа, например:

```bsl
&ПараметрыОтвета(ТипСодержимого = "html", КодОтвета = 200)
Процедура GET(Идентификатор) Экспорт

    Шаблонизатор = Новый Шаблонизатор(ЭтотОбъект, Контекст);
    ТекстШаблона = Шаблонизатор.Сформировать("Ядро.Главная");
    Контекст.Ответ.Записать(ТекстШаблона);

КонецПроцедуры
```

Так же есть более удобная и сокращенная запись:

```bsl
&ПараметрыОтвета(ТипСодержимого = "html", КодОтвета = 200)
&ФормироватьШаблон("Ядро.Главная")
Процедура GET(Идентификатор) Экспорт
    // Код обработки
КонецПроцедуры
```

При наличии у процедуры обработчика запроса аннотации ```&ФормироватьШаблон(<путь к шаблонку>)``` автоматически формирует нужный шаблон передавая в него текущее представление и контекст, и отправляет ответ если этого не было сделано раннее, формирование шаблона происходит после выполнения кода обработчика запроса.

<a id="servises" />

### Разработка и использование сервисов

Сервисы - это слой, в котором реализуется бизнес-логика компонента, каждый созданный сервис создаётся как обычный скрипт, определяется фреймворком как класс и доступен для использования во всём приложении. Создавать сервисы можно во вложенных каталогах в целях структуризации.

Например, создадим несколько сервисов:

```md
└── Компонент
    └── Сервисы
        └── ОбщегоНазначения
            ├── ДатаВремя.os
            └── СтроковыеФункции.os
```

Для того, чтобы использовать программный интерфейс, в объекте, где его нужно использовать, необходимо создать свойство и присовить ему специальную аннотацию, пример:

```bsl
&Сервис("ОбщегоНазначения.СтроковыеФункции")
Перем СтроковыеФункции;
```

Следует учесть, что если сервис используется в объекте компонента, который находится в том же компоненте, что и сам сервис, то указание параметра аннотации "Сервис" должен писаться в сокращенном виде:

```bsl
&Сервис("ОбщегоНазначения.СтроковыеФункции")
Перем СтроковыеФункции;
```

Если же сервис используется в другом компоненте, тогда необходимо прописать полный путь:

```bsl
&Сервис("Ядро.Сервисы.ОбщегоНазначения.СтроковыеФункции")
Перем СтроковыеФункции;
```

Далее сервисы можно использовать в других сервисах и в представлениях любых компонентов приложения.

<a id="static" />

### Статические файлы

Встроенный web-сервер позволяет отдавать статические файлы, для этого необходимо разместить файл в каталоге "Ресурсы" вашего компонента. При этом струкура каталогов в каталоге "Ресурсы" учитывается при генерации маршрутов.

Адрес к каждому статическому файлу будет формироваться по следующему шаблону:
```<адрес сервера или ip>/<латинское имя компонента>/<путь к статическому файлу>```

Например, если в компоненте Ядро (core), в ресурсах размещен файл index.html:
```http://127.0.0.1:5555/core/index.html```

Если необходимо, чтобы статический файл был доступен в корне приложения, то есть возможность при инициализации компонента установить третий параметр в "Истина":

```bsl
#Использовать onecore

// Подключение компонентов
Приложение.ПодключитьКомпонент("Ядро", "core", Истина);

// Инициализация и запуск
Приложение.Инициализировать();
Приложение.Запустить();
```

Далее все ресурсы компонента будут доступны по нескольким адресам:
```http://127.0.0.1:5555/index.html``` и ```http://127.0.0.1:5555/core/index.html```

<a id="Middleware" />

### Перехватчики (Middleware)

Фреймворк позволяет перехватывать выполнение запроса перед обработкой представлением и перед отправкой ответа, это позволяет гибко управлять данными для отправки. Перехватчики отрабатывают в той очередности, в которой они указаны разработчиком, при этом сначала запускаются процедуры "ПередВыполнениемПредставления" перед отправкой в представление, и уже после обработки представлением в том же порядке выполняются процедуры "ПослеВыполненияПредставления". Для написания обработчиков перехватчиков используются сервисы, а в стартовом файле прописываются пути к сервисам перехватчиков. Для того, чтобы обработать событие необходимо создать экспортные процедуры "ПередВыполнениемПредставления" или/и ПослеВыполненияПредставления, указав в них 2 параметра: Контекст и ПродолжитьОбработку. Для инициализации сервисов перехватчиков нужно воспользоваться объектом "МенеджерОбъектов", получить его можно с помощью модуля глобального контекста "Приложение", "Приложение.МенеджерКомпонентов()".

Пример стартового скрипта:

```bsl
#Использовать onecore

// Подключение компонентов
Приложение.ПодключитьКомпонент("Ядро", "core", Истина);

// Подключение перехватчиков
Приложение.ПодключитьПерехватчик("Ядро.Перехватчики.ПроверкаТокена");

// Инициализация и запуск
Приложение.Инициализировать();
Приложение.Запустить();
```

В метод ИнициализироватьПерехватчики менеджера объектов можно передавать сервисы через запятую или массивом строк, как вам будет удобнее.

Пример сервиса перехватчика по пути: ```Ядро/Сервисы/Перехватчики/ПроверкаТокена.os```

```bsl
Процедура ПередВыполнениемПредставления(Контекст, ПродолжитьОбработку) Экспорт

    Лог.Отладка("Проверяю токен");
    Токен = Контекст.Запрос.Заголовки.Получить("Token");

    Если НЕ ЗначениеЗаполнено(Токен) Тогда
        Ответ.Отправить(401);
        Лог.Отладка("Отсутствует токен в заголовках");
    КонецЕсли;

    Лог.Отладка("Токен типа проверен");

КонецПроцедуры

Процедура ПослеВыполненияПредставления(Контекст, ПродолжитьОбработку) Экспорт

    Лог.Отладка("Что-то делаем после того, как обработалось представление");

КонецПроцедуры
```

Перед выполнением каждой процедуры сервиса перехватчика проверяется признак отправленности ответа, в случае, если ответ отправлен, процедура не будет выполнена.
Если необходимо прервать дальнейшее выполнение обработки запроса необходмо параметр "ПродолжитьОбработку" установить в Ложь.

<a id="entity" />

### Работа с базой данных (ORM)

Для работы с базами данных в фреймворк встроена ORM [entity](https://github.com/oscript-library/entity), так же вас ни кто не ограничивает использовать и другие библиотеки по работе с базами данных, но именно entity интегрирована в onecore. Интеграция заключается в том, что фреймворк автоматически сканирует все скрипты в каталогах компонентов "Модели" и добавляет их в entity, так же проводит инициализацию моделей при инициализации приложения.

Что бы использовать entity в onecore нужно в первую очередь включить поддержку ORM и указать какую базу использовать в файле ```main.os```:

```bsl
#Использовать "onecore"

// Подключение функционала
Приложение.ИспользоватьORM();
Приложение.ПодключитьБазуДанныхORM("Основная");
Приложение.ПодключитьБазуДанныхORM("Файловая", "КоннекторSQLite", "FullUri=file:main.db");

// Подключение компонентов
Приложение.ПодключитьКомпонент("Ядро", "core", Истина);

// Подключение перехватчиков
Приложение.ПодключитьПерехватчик("Ядро.Перехватчики.ПроверкаТокена");

// Инициализация и запуск
Приложение.Инициализировать();
Приложение.Запустить();
```

Процедура ```ПодключитьБазуДанныхORM``` принимает в себя 3 параметра:

1. Ключ - Строка - Ключ по которому будет определятся какой конкретно менеджер сущностей использовать
2. ТипКоннектора - Строка - Тип коннектора строкой, см. документацию entity (не обязательно)
3. СтрокаСоединения - Строка - Строка соединения по формату выбранного коннектора (не обязательно)

Из выше описанного следует, что есть возможность использовать несколько менеджеров сущностей и следовательно несколько баз данных, если второй и третий параметры не указаны, то их необходимо будет указать в файле ```settings.json```:

```json
{
    "Приложение": {
        "ПортПрослушивания": 8572,
        "РежимРазработки": true,
        "УровеньВыводаЛогов": "Отладка",
        "БазыДанныхORM": {
            "Основная": {
                "ТипКоннектора": "КоннекторPostgreSQL",
                "СтрокаСоединения": "Host=***;Username=***;Password=***;Database=***;port=5432;"
            }
        }
    }
}
```

Данный инструментарий позволяет задать настройки подключения к базе данных программным путем используя механизм настроек.

После включения поддержки ORM и указания параметров для подключения к базе данных менеджеры сущностей можно использовать в любом месте программы, для этого потребуется использовать аннотацию ```&МенеджерСущностей(<Ключ>)```, например в модуле представления (но лучше только в сервисах):

```bsl
Перем Контекст;

&МенеджерСущностей("Основная")
Перем МенеджерСущностей;

Процедура Инициализация() Экспорт
    Контекст.Данные.Вставить("ЗаголовокВкладки", "Физические лица");
КонецПроцедуры

&ПараметрыОтвета(ТипСодержимого = "html", КодОтвета = 200)
&ФормироватьШаблон("Ядро.Шаблоны.Справочники.ФизическиеЛица.Список")
Процедура GET() Экспорт

    ОпцииПоиска = Новый ОпцииПоиска().СортироватьПо("Идентификатор", НаправлениеСортировки.Возр);
    СписокФизЛиц = МенеджерСущностей.Получить(Тип("ЯдроФизическоеЛицо"), ОпцииПоиска);

    Таблица.Колонки.Добавить("Идентификатор");
    Таблица.Колонки.Добавить("Номер");
    Таблица.Колонки.Добавить("Фамилия");
    Таблица.Колонки.Добавить("Имя");
    Таблица.Колонки.Добавить("Отчество");

    Номер = 1;

    Для каждого ФизЛицо Из СписокФизЛиц Цикл
        НоваяСтрока = Таблица.Добавить();
        НоваяСтрока.Идентификатор = ФизЛицо.Идентификатор;
        НоваяСтрока.Номер = Номер;
        НоваяСтрока.Фамилия = ФизЛицо.Фамилия;
        НоваяСтрока.Имя = ФизЛицо.Имя;
        НоваяСтрока.Отчество = ФизЛицо.ВтороеИмя;
        Номер = Номер + 1;
    КонецЦикла;

    Контекст.Данные.Вставить("Список", Таблица);

КонецПроцедуры
```

Из примера следует, что в переменную ```МенеджерСущностей``` с помощью аннотации был помещен экзепляр класса ```МенеджерСущностей``` библиотеки entity, и далее согласно документации этой библиотеки вы можете осуществлять все доступные действия с объектами ORM.

P.S: Документация ещё не дописана полностью, не хватает полного API, деталей и примеров, в связи с этим принято решение разработать сайт для документации, ожидается "когдато" :)
