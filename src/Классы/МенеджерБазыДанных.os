// BSLLS:DuplicateStringLiteral-off
// BSLLS:NumberOfValuesInStructureConstructor-off
#Использовать fs
#Использовать asserts
#Использовать json
#Использовать sql

// Глобальный объект модуля менеджера сущностей
Перем МенеджерСущностей;
// Таблица значений хранящая все модели приложения
Перем ТаблицаМоделей;
// Путь хранения json с сохраненным в базе данных состоянием таблиц
Перем ПутьКФайлуСостоянияТаблиц;
// Строка соединения к базе данных
Перем СтрокаСоединения;
// Последнее соединение
Перем ТекущееСоединение;
Перем ПоследнееСообщениеОбОшибке;
// Экземпляр коннектора базы данных
Перем КоннекторPostgreSQL;

// Инициализирует необходимые данные для работы с базой данных
//
Процедура Инициализировать() Экспорт

	ПутьКФайлуСостоянияТаблиц = ОбъединитьПути(Служебное.КаталогПриложения(), "tables.json");
	НастройкиПодключения = Настройки.Получить("Приложение.БазаДанных");
	ТекстОшибкиПодключения = "";
	
	Если НастройкиПодключения = Неопределено Тогда
		Лог.Ошибка("Настройки подключения к базе данных не инициализированы");
		Возврат;
	КонецЕсли;

	СтрокаСоединения = СтрШаблон("Host=%1;Username=%2;Password=%3;Database=%4;port=%5;",
								НастройкиПодключения.Адрес,
								НастройкиПодключения.Пользователь,
								НастройкиПодключения.Пароль,
								НастройкиПодключения.ИмяБазы,
								НастройкиПодключения.Порт);

	ТекущееСоединение = Новый Соединение();
	ТекущееСоединение.ТипСУБД = ТекущееСоединение.ТипыСУБД.PostgreSQL;
	ТекущееСоединение.СтрокаСоединения = СтрокаСоединения;
	ТекущееСоединение.Открыть();

	ПоследнееСообщениеОбОшибке = ТекущееСоединение.ПоследнееСообщениеОбОшибке;

	Если ТекущееСоединение.Открыто Тогда
		Лог.Информация("Подключение к базе данных выполнено успешно");
		СинхронизироватьТаблицыСМоделями();
	Иначе
		Лог.Ошибка(СтрШаблон("Подключение к базе данных не возможно, по причине: %1", ТекстОшибкиПодключения));
	КонецЕсли;
	
КонецПроцедуры

Процедура СоздатьТаблицу(ОписаниеТаблицыМодели) Экспорт
	
	ИмяТаблицы = ОписаниеТаблицыМодели.ИмяТаблицы();
	ИмяМодели = ОписаниеТаблицыМодели.ИмяМодели();
	ПоляТаблицы = ОписаниеТаблицыМодели.ПоляМодели();
	
	// Создаем таблицу
	ТекстЗапроса = СтрШаблон("CREATE TABLE IF NOT EXISTS %1 ();", ИмяТаблицы);
	
	Запрос = Новый Запрос();
	Запрос.УстановитьСоединение(ТекущееСоединение);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Запрос.Выполнить();
		Лог.Информация(СтрШаблон("Таблица %1 успешно создана", ИмяТаблицы));
		
		// Добавляем комментарий к таблице с информацией о модели
		ТекстЗапроса = СтрШаблон("COMMENT ON TABLE %1 IS '{""orm_name"": ""%2""}';", ИмяТаблицы, ИмяМодели);
		Запрос.Текст = ТекстЗапроса;
		Запрос.Выполнить();
		
		// Добавляем поля
		Для Каждого Поле Из ПоляТаблицы Цикл
			ДобавитьПолеВТаблицу(ИмяТаблицы, Поле);
		КонецЦикла;
		
	Исключение
		Лог.Ошибка(СтрШаблон("Ошибка создания таблицы %1: %2", ИмяТаблицы, ПоследнееСообщениеОбОшибке));
	КонецПопытки;
	
КонецПроцедуры

// Добавляет новое поле в существующую таблицу
//
// Параметры:
//   ИмяТаблицы - Строка - Имя таблицы
//   Поле - Структура - Описание поля
//
Процедура ДобавитьПолеВТаблицу(ИмяТаблицы, Поле) Экспорт
	
	ОписаниеПоля = СоздатьОписаниеПоля(Поле.ИмяКолонки, Поле.Тип, Поле.ПараметрыТипа);
	ТекстЗапроса = СтрШаблон("ALTER TABLE %1 ADD COLUMN %2;", ИмяТаблицы, ОписаниеПоля);
	
	Запрос = Новый Запрос();
	Запрос.УстановитьСоединение(ТекущееСоединение);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Запрос.Выполнить();
		
		// Добавляем комментарий к полю
		ТекстЗапроса = СтрШаблон("COMMENT ON COLUMN %1.%2 IS '{""orm_name"": ""%3""}';", 
			ИмяТаблицы, 
			Поле.ИмяКолонки,
			Поле.ИмяПоля);
		
		Запрос.Текст = ТекстЗапроса;
		Запрос.Выполнить();
		
	Исключение
		Лог.Ошибка(СтрШаблон("Ошибка добавления поля %1 в таблицу %2: %3", 
			Поле.ИмяКолонки, 
			ИмяТаблицы, 
			ПоследнееСообщениеОбОшибке));
	КонецПопытки;
	
КонецПроцедуры

// Переименовывает поле в существующей таблице
//
// Параметры:
//   ИмяТаблицы - Строка - Имя таблицы
//   СтароеИмяПоля - Строка - Текущее имя поля
//   НовоеИмяПоля - Строка - Новое имя поля
//
Процедура ПереименоватьПолеТаблицы(ИмяТаблицы, СтароеИмяПоля, НовоеИмяПоля) Экспорт
	
	ТекстЗапроса = СтрШаблон("ALTER TABLE %1 RENAME COLUMN %2 TO %3;", 
		ИмяТаблицы, 
		СтароеИмяПоля,
		НовоеИмяПоля);
	
	Запрос = Новый Запрос();
	Запрос.УстановитьСоединение(ТекущееСоединение);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Запрос.Выполнить();
	Исключение
		Лог.Ошибка(СтрШаблон("Ошибка переименования поля %1 в %2 для таблицы %3: %4", 
			СтароеИмяПоля,
			НовоеИмяПоля,
			ИмяТаблицы,
			ПоследнееСообщениеОбОшибке));
	КонецПопытки;
	
КонецПроцедуры

// Изменяет имя ORM поля в комментарии таблицы
//
// Параметры:
//   ИмяТаблицы - Строка - Имя таблицы
//   ИмяПоля - Строка - Имя поля
//   НовоеИмяORMПоля - Строка - Новое имя ORM поля
//
Процедура СменитьИмяORMПоляТаблицы(ИмяТаблицы, ИмяПоля, НовоеИмяORMПоля) Экспорт
	
	ТекстЗапроса = СтрШаблон("COMMENT ON COLUMN %1.%2 IS '{""orm_name"": ""%3""}';",
		ИмяТаблицы,
		ИмяПоля,
		НовоеИмяORMПоля);
	
	Запрос = Новый Запрос();
	Запрос.УстановитьСоединение(ТекущееСоединение);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Запрос.Выполнить();
	Исключение
		Лог.Ошибка(СтрШаблон("Ошибка изменения ORM имени поля %1 на %2 для таблицы %3: %4",
			ИмяПоля,
			НовоеИмяORMПоля,
			ИмяТаблицы,
			ПоследнееСообщениеОбОшибке));
	КонецПопытки;
	
КонецПроцедуры

// Изменяет тип поля в существующей таблице
//
// Параметры:
//   ИмяТаблицы - Строка - Имя таблицы
//   ИмяПоля - Строка - Имя поля
//   НовыйТип - Тип - Новый тип данных поля
//   ПараметрыТипа - Структура - Параметры типа данных (длина, точность и т.д.)
//
Процедура СменитьТипПоля(ИмяТаблицы, ИмяПоля, НовыйТип, ПараметрыТипа = Неопределено) Экспорт
	
	ТипSQL = ПреобразоватьВТипSQL(НовыйТип, ПараметрыТипа);
	
	Если ТипSQL = Неопределено Тогда
		ВызватьИсключение СтрШаблон("Не удалось определить тип SQL для поля %1", ИмяПоля);
	КонецЕсли;
	
	ТекстЗапроса = СтрШаблон("ALTER TABLE %1 ALTER COLUMN %2 TYPE %3;",
		ИмяТаблицы,
		ИмяПоля,
		ТипSQL);
	
	Запрос = Новый Запрос();
	Запрос.УстановитьСоединение(ТекущееСоединение);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Запрос.Выполнить();
	Исключение
		Лог.Ошибка(СтрШаблон("Ошибка изменения типа поля %1 на %2 для таблицы %3: %4",
			ИмяПоля,
			ТипSQL,
			ИмяТаблицы,
			ПоследнееСообщениеОбОшибке));
	КонецПопытки;
	
КонецПроцедуры

// Удаляет поле из существующей таблицы
//
// Параметры:
//   ИмяТаблицы - Строка - Имя таблицы
//   ИмяПоля - Строка - Имя удаляемого поля
//
Процедура УдалитьПолеИзТаблицы(ИмяТаблицы, ИмяПоля) Экспорт
	
	ТекстЗапроса = СтрШаблон("ALTER TABLE %1 DROP COLUMN %2;", ИмяТаблицы, ИмяПоля);
	
	Запрос = Новый Запрос();
	Запрос.УстановитьСоединение(ТекущееСоединение);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Запрос.Выполнить();
	Исключение
		Лог.Ошибка(СтрШаблон("Ошибка удаления поля %1 из таблицы %2: %3", 
			ИмяПоля, 
			ИмяТаблицы, 
			ПоследнееСообщениеОбОшибке));
	КонецПопытки;
	
КонецПроцедуры

// Параметры:
//   ИмяПоля - Строка - Имя поля
//   Тип - Тип - Тип данных поля
//   ПараметрыТипа - Структура - Параметры типа данных (длина, точность и т.д.)
//   ПервичныйКлюч - Булево - Признак первичного ключа
//
// Возвращаемое значение:
//   Строка - SQL описание поля
//
Функция СоздатьОписаниеПоля(ИмяПоля, Тип, ПараметрыТипа = Неопределено) Экспорт
	
	ТипSQL = ПреобразоватьВТипSQL(Тип, ПараметрыТипа);
	
	Если ТипSQL = Неопределено Тогда
		ВызватьИсключение СтрШаблон("Не удалось определить тип SQL для поля %1", ИмяПоля);
	КонецЕсли;
	
	ОписаниеПоля = СтрШаблон("%1 %2", ИмяПоля, ТипSQL);
	
	Если ПараметрыТипа.Свойство("ПервичныйКлюч") Тогда
		ОписаниеПоля = ОписаниеПоля + " PRIMARY KEY";
	КонецЕсли;
	
	Возврат ОписаниеПоля;
	
КонецФункции

Функция ПреобразоватьВТипSQL(Тип, ПараметрыТипа = Неопределено) Экспорт
	
	СоответствиеТипов = Новый Соответствие();
	СоответствиеТипов.Вставить(Тип("Строка"), "VARCHAR, TEXT");
	СоответствиеТипов.Вставить(Тип("Число"), "NUMERIC(precision, scale)");
	СоответствиеТипов.Вставить(Тип("Дата"), "TIMESTAMP");
	СоответствиеТипов.Вставить(Тип("Булево"), "BOOLEAN");
	СоответствиеТипов.Вставить(Тип("ДвоичныеДанные"), "BYTEA");
	СоответствиеТипов.Вставить(Тип("УникальныйИдентификатор"), "UUID");

	НайденныйТип = СоответствиеТипов[Тип];

	Если НайденныйТип = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Обработка типа строка
	Если Тип = Тип("Строка") Тогда
		
		Длина = Неопределено;
		
		Если НЕ ПараметрыТипа.Свойство("Длина", Длина) Тогда
			Длина = 0;
		КонецЕсли;

		Если Длина = 0 Тогда
			Возврат "TEXT";
		Иначе
			Возврат СтрШаблон("VARCHAR(%1)", Строка(Длина));
		КонецЕсли;

	КонецЕсли;

	// Обработка типа число
	Если Тип = Тип("Число") Тогда
		
		Длина = 0;
		Точность = 0;

		Если НЕ ПараметрыТипа.Свойство("Длина", Длина) ИЛИ НЕ ПараметрыТипа.Свойство("Точность", Точность) Тогда
			Лог.Ошибка("У типа Число не переданы параметры");
			Возврат Неопределено;
		КонецЕсли;

		Возврат СтрШаблон("NUMERIC(%1, %2)", Строка(Длина), Строка(Точность));

	КонецЕсли;

	Возврат НайденныйТип;

КонецФункции

// Преобразует тип SQL в тип программы
//
// Параметры:
//   ТипSQL - Строка - Тип данных SQL
//   Размер - Число - Размер поля (для строковых типов)
//   Точность - Число - Точность (для числовых типов)
//   Масштаб - Число - Масштаб (для числовых типов)
//
// Возвращаемое значение:
//   Тип - Тип данных программы
//
Функция ПреобразоватьИзТипаSQL(ТипSQL, Размер = Неопределено, Точность = Неопределено, Масштаб = Неопределено) Экспорт
	
	ТипSQL = НРег(ТипSQL);
	
	// Все типы данных
	ТипыДанных = Новый Соответствие;
	// Строковые типы
	ТипыДанных.Вставить("varchar", Тип("Строка"));
	ТипыДанных.Вставить("text", Тип("Строка"));
	ТипыДанных.Вставить("character varying", Тип("Строка"));
	
	// Числовые типы
	ТипыДанных.Вставить("numeric", Тип("Число"));
	ТипыДанных.Вставить("decimal", Тип("Число"));
	ТипыДанных.Вставить("integer", Тип("Число"));
	ТипыДанных.Вставить("bigint", Тип("Число"));
	ТипыДанных.Вставить("smallint", Тип("Число"));
	ТипыДанных.Вставить("real", Тип("Число"));
	ТипыДанных.Вставить("double precision", Тип("Число"));
	
	// Дата/время
	ТипыДанных.Вставить("timestamp", Тип("Дата"));
	ТипыДанных.Вставить("date", Тип("Дата"));
	ТипыДанных.Вставить("time", Тип("Дата"));
	
	// Логический
	ТипыДанных.Вставить("boolean", Тип("Булево"));
	
	// Бинарные данные
	ТипыДанных.Вставить("bytea", Тип("ДвоичныеДанные"));
	
	// UUID
	ТипыДанных.Вставить("uuid", Тип("УникальныйИдентификатор"));
	
	НайденныйТип = ТипыДанных[ТипSQL];
	
	// Если тип не определен - возвращаем строковый тип
	Если НайденныйТип = Неопределено Тогда
		Возврат Тип("Строка");
	КонецЕсли;

	Возврат НайденныйТип;

КонецФункции

Функция ОбъектЯвляетсяМоделью(ПроверяемыйОбъект) Экспорт
	
	ИмяТаблицы = "";
	Тип = ТипЗнч(ПроверяемыйОбъект);

	Если НЕ Рефлексия.МетодСуществует(ПроверяемыйОбъект, "ПриСозданииОбъекта") Тогда
		Лог.Предупреждение(СтрШаблон("У типа %1 не объявлен метод 'ПриСозданииОбъекта'", Строка(Тип)));
		Возврат Ложь;	
	КонецЕсли;

	Аннотации = Рефлексия.АннотацииМетода(ПроверяемыйОбъект, "ПриСозданииОбъекта");

	Если НЕ Аннотации.Свойство("Модель") Тогда
		Лог.Предупреждение(СтрШаблон("У типа %1 отсутствует аннотация 'Модель'", Строка(Тип)));
		Возврат Ложь;
	КонецЕсли;

	Если НЕ Аннотации.Модель.Свойство("Имя", ИмяТаблицы) Тогда
		Лог.Предупреждение(СтрШаблон("У типа %1 в аннотации 'Модель' не указан параметр 'Имя'", Строка(Тип)));
		Возврат Ложь;
	КонецЕсли;

	Если НЕ Служебное.СоответствуетCamelCase(ИмяТаблицы) Тогда
		Шаблон = "У типа %1 имя таблицы содержит кириллические символы или не соответствует CamelCase";
		Лог.Предупреждение(СтрШаблон(Шаблон, Строка(Тип)));
	КонецЕсли;

	Свойства = Рефлексия.ПолучитьТаблицуСвойств(ПроверяемыйОбъект);
	СвойствоИдентификатор = Неопределено;
	ПрисутствуютОшибки = Ложь;

	Для каждого СтрокаСвойства Из Свойства Цикл

		АннотацииСвойства = Рефлексия.АннотацииСвойства(ПроверяемыйОбъект, СтрокаСвойства.Имя);

		Если АннотацииСвойства.Свойство("Идентификатор") Тогда
			СвойствоИдентификатор = СтрокаСвойства;
		КонецЕсли;

		Если НЕ АннотацииСвойства.Свойство("Поле") Тогда
			Продолжить;
		КонецЕсли;

		ИмяКолонки = "";

		Если НЕ АннотацииСвойства.Поле.Свойство("Имя", ИмяКолонки) Тогда
			Лог.Предупреждение(СтрШаблон("У типа %1 в свойстве %2 не указано имя колонки", Строка(Тип), СтрокаСвойства.Имя));
			ПрисутствуютОшибки = Истина;
			Продолжить;
		КонецЕсли;

		Если НЕ Служебное.СоответствуетCamelCase(ИмяКолонки) Тогда
			Шаблон = "У типа %1 в свойстве %2 имя содержит кириллические символы или не соответствует CamelCase";
			Лог.Предупреждение(СтрШаблон(Шаблон, Строка(Тип), СтрокаСвойства.Имя));
			ПрисутствуютОшибки = Истина;
			Продолжить;
		КонецЕсли;

		Если НЕ АннотацииСвойства.Поле.Свойство("Тип", ИмяКолонки) Тогда
			Лог.Предупреждение(СтрШаблон("У типа %1 в свойстве %2 не указан тип", Строка(Тип), СтрокаСвойства.Имя));
			ПрисутствуютОшибки = Истина;
			Продолжить;
		КонецЕсли;

	КонецЦикла;

	Если СвойствоИдентификатор = Неопределено Тогда
		Лог.Предупреждение(СтрШаблон("У типа %1 не обнаружено свойство идентификатор", Строка(Тип)));
		Возврат Ложь;
	КонецЕсли;

	Возврат НЕ ПрисутствуютОшибки;

КонецФункции

Функция ТаблицаСуществует(ИмяТаблицы)
	
	// Проверяем существование таблицы по имени или значению orm_name в комментарии
	ТекстЗапроса = "
	|SELECT EXISTS (
	|	SELECT FROM information_schema.tables t
	|	JOIN pg_class c ON c.relname = t.table_name
	|	WHERE t.table_name = '%1'
	|		OR pg_catalog.obj_description(c.oid, 'pg_class')::jsonb->>'orm_name' = '%1'
	|)";

	Запрос = Новый Запрос();
	Запрос.УстановитьСоединение(ТекущееСоединение);
	Запрос.Текст = СтрШаблон(ТекстЗапроса, ИмяТаблицы);
	Возврат Булево(Запрос.ВыполнитьКоманду());

КонецФункции

Функция ПолучитьОписаниеТаблицы(ОписаниеТаблицы)
	
	// Формируем запрос для получения информации о таблице и ее полях
	ТекстЗапроса = "
	|SELECT 
	|	col.column_name,
	|	col.data_type,
	|	col.character_maximum_length,
	|	col.numeric_precision,
	|	col.numeric_scale,
	|	col.is_nullable,
	|	col.column_default,
	|	pg_catalog.col_description(c.oid, col.ordinal_position) as column_comment,
	|	pg_catalog.obj_description(c.oid, 'pg_class') as table_comment
	|FROM information_schema.columns col
	|JOIN pg_class c ON c.relname = col.table_name
	|JOIN pg_namespace n ON n.oid = c.relnamespace
	|WHERE (col.table_name = '%1' AND n.nspname = current_schema())
	|	OR pg_catalog.obj_description(c.oid, 'pg_class')::jsonb->>'orm_name' = '%2'
	|ORDER BY col.ordinal_position";	
	Запрос = Новый Запрос();
	Запрос.УстановитьСоединение(ТекущееСоединение);
	Запрос.Текст = СтрШаблон(ТекстЗапроса, ОписаниеТаблицы.ИмяТаблицы(), ОписаниеТаблицы.ИмяМодели());
	
	Результат = Запрос.Выполнить().Выгрузить();
	
	Если Результат.Количество() = 0 Тогда
		ВызватьИсключение СтрШаблон("Таблица %1 не найдена в базе данных", ОписаниеТаблицы.ИмяТаблицы());
	КонецЕсли;
	
	// Создаем структуру для хранения информации о таблице
	ОписаниеИзБД = Новый Структура;
	
	// Разбор комментария таблицы для получения имени таблицы и модели
	ИмяТаблицыИзКомментария = "";
	ИмяМоделиИзКомментария = "";
	Если ЗначениеЗаполнено(Результат[0].table_comment) Тогда
		Попытка
			КомментарийТаблицы = Сериализация.ДесериализоватьJSON(Результат[0].table_comment);
			Если КомментарийТаблицы.Свойство("table_name") Тогда
				ИмяТаблицыИзКомментария = КомментарийТаблицы.table_name;
			КонецЕсли;
			Если КомментарийТаблицы.Свойство("orm_name") Тогда
				ИмяМоделиИзКомментария = КомментарийТаблицы.orm_name;
			КонецЕсли;
		Исключение
			// Игнорируем ошибки разбора JSON
		КонецПопытки;
	КонецЕсли;
	
	ОписаниеИзБД.Вставить("ИмяТаблицы", ?(ЗначениеЗаполнено(ИмяТаблицыИзКомментария), ИмяТаблицыИзКомментария, ОписаниеТаблицы.ИмяТаблицы()));
	ОписаниеИзБД.Вставить("ИмяМодели", ?(ЗначениеЗаполнено(ИмяМоделиИзКомментария), ИмяМоделиИзКомментария, ОписаниеТаблицы.ИмяМодели()));
	ОписаниеИзБД.Вставить("Поля", Новый Массив);
	
	Для Каждого Строка Из Результат Цикл
		// Разбор комментария колонки для получения orm_name
		ИмяПоляORM = "";
		Если ЗначениеЗаполнено(Строка.column_comment) Тогда
			Попытка
				КомментарийКолонки = Сериализация.ДесериализоватьJSON(Строка.column_comment);
				Если КомментарийКолонки["orm_name"] <> Неопределено Тогда
					ИмяПоляORM = КомментарийКолонки["orm_name"];
				КонецЕсли;
			Исключение
				// Игнорируем ошибки разбора JSON
			КонецПопытки;
		КонецЕсли;
		
		// Создаем описание поля
		ОписаниеПоля = Новый Структура;
		ОписаниеПоля.Вставить("ИмяКолонки", Строка.column_name);
		ОписаниеПоля.Вставить("ТипДанных", Строка.data_type);
		ОписаниеПоля.Вставить("Размер", Строка.character_maximum_length);
		ОписаниеПоля.Вставить("Точность", Строка.numeric_precision);
		ОписаниеПоля.Вставить("Масштаб", Строка.numeric_scale);
		ОписаниеПоля.Вставить("ДопускаетНуль", Строка.is_nullable = "YES");
		ОписаниеПоля.Вставить("ЗначениеПоУмолчанию", Строка.column_default);
		ОписаниеПоля.Вставить("ИмяПоля", ИмяПоляORM);
		
		ОписаниеИзБД.Поля.Добавить(ОписаниеПоля);
	КонецЦикла;
	
	Возврат ОписаниеИзБД;
	
КонецФункции

Процедура СинхронизироватьТаблицыСМоделями()
	
	МенеджерКомпонентов = Приложение.МенеджерКомпонентов();
	Компоненты = МенеджерКомпонентов.Компоненты();
	
	СоответствиеМоделейТаблиц = Новый Соответствие();

	Для каждого Компонент Из Компоненты Цикл

		ОписанияТаблицМоделей = Компонент.ОписанияТаблицМоделей();

		Для каждого СтрокаОписания Из ОписанияТаблицМоделей Цикл
			
			Если ТаблицаСуществует(СтрокаОписания.ОписаниеМодели.ИмяТаблицы()) Тогда
				ОписаниеИзБД = ПолучитьОписаниеТаблицы(СтрокаОписания.ОписаниеМодели);
			Иначе
				ОписаниеИзБД = Неопределено;
			КонецЕсли;

			СоответствиеМоделейТаблиц.Вставить(СтрокаОписания.ОписаниеМодели, ОписаниеИзБД);

		КонецЦикла;

	КонецЦикла;
	
	// Обработка соответствия моделей и таблиц
	Для каждого КлючИЗначение Из СоответствиеМоделейТаблиц Цикл
		
		ОписаниеМодели = КлючИЗначение.Ключ;
		ОписаниеТаблицы = КлючИЗначение.Значение;
		
		// Если таблицы нет - создаем
		Если ОписаниеТаблицы = Неопределено Тогда
			СоздатьТаблицу(ОписаниеМодели);
			Продолжить;
		КонецЕсли;
		
		// Проверяем соответствие имен таблиц и моделей
		Если ОписаниеТаблицы.ИмяТаблицы <> ОписаниеМодели.ИмяТаблицы() Тогда
			ПереименоватьТаблицу(ОписаниеТаблицы.ИмяТаблицы, ОписаниеМодели.ИмяТаблицы());
		КонецЕсли;
		
		// Проверяем поля
		ПоляМодели = ОписаниеМодели.ПоляМодели();
		ПоляТаблицы = ОписаниеТаблицы.Поля;
		
		// Создаем индекс полей таблицы по имени для быстрого поиска
		ИндексПолейТаблицы = Новый Соответствие();
		Для каждого ПолеТаблицы Из ПоляТаблицы Цикл
			ИндексПолейТаблицы.Вставить(ПолеТаблицы.ИмяКолонки, ПолеТаблицы);
		КонецЦикла;
		
		// Проверяем каждое поле модели
		Для каждого ПолеМодели Из ПоляМодели Цикл
			
			ПолеТаблицы = Неопределено;
			
			// Поиск поля по имени колонки или ORM имени
			Для каждого ТекущееПолеТаблицы Из ПоляТаблицы Цикл
				Если ТекущееПолеТаблицы.ИмяКолонки = ПолеМодели.ИмяКолонки 
					ИЛИ ТекущееПолеТаблицы.ИмяКолонки = ПолеМодели.ИмяПоля Тогда
					ПолеТаблицы = ТекущееПолеТаблицы;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			// Если поля нет - добавляем
			Если ПолеТаблицы = Неопределено Тогда
				ДобавитьПолеВТаблицу(ОписаниеМодели.ИмяТаблицы(), ПолеМодели);
				Продолжить;
			КонецЕсли;
			
			// Проверяем имя колонки
			Если ПолеТаблицы.ИмяКолонки <> ПолеМодели.ИмяКолонки Тогда
				ПереименоватьПолеТаблицы(ОписаниеМодели.ИмяТаблицы(), ПолеТаблицы.ИмяКолонки, ПолеМодели.ИмяКолонки);
			КонецЕсли;
			
			// Проверяем ORM имя
			Если ПолеТаблицы.ИмяПоля <> ПолеМодели.ИмяПоля Тогда
				СменитьИмяORMПоляТаблицы(ОписаниеМодели.ИмяТаблицы(), ПолеМодели.ИмяКолонки, ПолеМодели.ИмяПоля);
			КонецЕсли;
			
			// Проверяем тип данных
			Если ПолеТаблицы.ТипДанных <> ПолеМодели.Тип Тогда
				СменитьТипПоля(ОписаниеМодели.ИмяТаблицы(), ПолеМодели.ИмяКолонки, ПолеМодели.Тип, ПолеМодели.ПараметрыТипа);
			КонецЕсли;
			
			// Удаляем обработанное поле из индекса
			ИндексПолейТаблицы.Удалить(ПолеТаблицы.ИмяКолонки);
			
		КонецЦикла;
		
		// Удаляем оставшиеся поля, которых нет в модели
		Для каждого ОставшеесяПоле Из ИндексПолейТаблицы Цикл
			УдалитьПолеИзТаблицы(ОписаниеМодели.ИмяТаблицы(), ОставшеесяПоле.Ключ);
		КонецЦикла;
		
	КонецЦикла;

КонецПроцедуры