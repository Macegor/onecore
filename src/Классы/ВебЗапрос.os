// BSLLS:ExportVariables-off

#Использовать strings

#Область ОписаниеПеременных

// TCPСоединение - Соединение генерируемое сервером, используется для ответа на запрос
Перем Соединение;
// Строка - Тип http запроса (GET/POST/PUD и т.д)
Перем ТипЗапроса;
// Строка - url адрес запрашиваемого ресурса
Перем Адрес;
// Строка - Версия протокола http
Перем ВерсияHTTP;
// Соответствие - Заголовки запроса
Перем Заголовки;
// Соответствие - Параметры запроса из url
Перем ПараметрыЗапроса;
// Строка, ДвоичныеДанные - Полученное тело
Перем Тело;

#КонецОбласти

#Область ОбработчикиСобытий

Процедура ПриСозданииОбъекта(Знач TCPСоединение)
	
	Соединение = TCPСоединение;
	ТипЗапроса = "";
	Адрес = "";
	ВерсияHTTP = "";
	Заголовки = Новый Соответствие();	
	ПараметрыЗапроса = Новый Соответствие();
	Тело = Неопределено;
		
	РазобратьЗапрос();

КонецПроцедуры

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Возвращает заголовки запроса
//
//  Возвращаемое значение:
//   Соответствие - заголовки запроса
//
Функция ПолучитьЗаголовки() Экспорт
	Возврат Заголовки;	
КонецФункции

// Возвращает url параметры запроса
//
//  Возвращаемое значение:
//   Соответствие - параметры запроса
//
Функция ПолучитьПараметрыЗапроса() Экспорт
	Возврат ПараметрыЗапроса;
КонецФункции

// Возвращает тело запроса как строку
//
//  Возвращаемое значение:
//   Строка - тело запроса
//
Функция ПолучитьТелоКакСтроку() Экспорт

	ТелоСтрокой = ПолучитьСтрокуИзДвоичныхДанных(Тело);
	ТелоСтрокой = РаскодироватьСтроку(ТелоСтрокой, СпособКодированияСтроки.URLВКодировкеURL);

	Возврат ТелоСтрокой; 
	
КонецФункции

Функция ПолучитьТелоКакДвоичныеДанные() Экспорт
	Возврат Тело; 
КонецФункции

#Область СлужебныйПрограммныйИнтерфейс

Функция ПолучитьАдрес() Экспорт
	Возврат Адрес;	
КонецФункции

Функция ПолучитьТипЗапроса() Экспорт
	Возврат ТипЗапроса;	
КонецФункции

Функция ПолучитьСоединение() Экспорт
	Возврат Соединение;		
КонецФункции

Функция ПолучитьВерсияHTTP() Экспорт
	Возврат ВерсияHTTP;		
КонецФункции

// Функция ПолучитьПользователя() Экспорт
	
// 	ЗаголовкиЗапроса = ПолучитьЗаголовки();
// 	ДанныеАвторизации = ЗаголовкиЗапроса["Authorization"];

// 	Если ДанныеАвторизации = Неопределено Тогда
// 		Возврат Неопределено;
// 	КонецЕсли;

// 	Если НЕ СтрНачинаетсяС(ДанныеАвторизации, "Bearer") Тогда
// 		Возврат Неопределено;
// 	КонецЕсли;	

// 	ТокенСтрокой = СокрЛП(СтрЗаменить(ДанныеАвторизации, "Bearer", ""));

// 	МенеджерСущностей = Приложение.ПолучитьМенеджерСущностей();

// 	ТокенДоступа = МенеджерСущностей.ПолучитьОдно(Тип("ТокенДоступа"), ТокенСтрокой);

// 	Если НЕ ЗначениеЗаполнено(ТокенДоступа) Тогда
// 		Возврат Неопределено;
// 	КонецЕсли;

// 	Если ТокенДоступа.ДатаВыдачи + ТокенДоступа.ВремяЖизни < ТекущаяУниверсальнаяДата() Тогда
// 		Возврат Неопределено;	
// 	КонецЕсли;

// 	Возврат ТокенДоступа.Пользователь;

// КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура РазобратьЗапрос()

	// Подготовливаем полученные строковые данные для обработки
	ДвоичныеДанныеЗаголовков = Новый Массив();
	ДвоичныеДанныеТела = Новый Массив();

	Пока Истина Цикл
		Попытка
			ПолученныеДвоичныеДанные = Соединение.ПрочитатьДвоичныеДанные();
			Если ТипЗнч(ДвоичныеДанныеЗаголовков) = Тип("Массив") Тогда
				РазделенныеДанные = РазделитьДвоичныеДанныеРазделителем(ПолученныеДвоичныеДанные, Константы.Получить("РазделительЗаголовковОтТелаЗапроса"));
				Если НЕ ЗначениеЗаполнено(РазделенныеДанные.Право) Тогда
					ДвоичныеДанныеЗаголовков.Добавить(РазделенныеДанные.Лево);
				Иначе
					ДвоичныеДанныеЗаголовков.Добавить(РазделенныеДанные.Лево);		
					ДвоичныеДанныеТела.Добавить(РазделенныеДанные.Право);
					ДвоичныеДанныеЗаголовков = СоединитьДвоичныеДанные(ДвоичныеДанныеЗаголовков);
					ПодготовитьЗаголовки(ДвоичныеДанныеЗаголовков);
				КонецЕсли;			
			Иначе
				ДвоичныеДанныеТела.Добавить(ПолученныеДвоичныеДанные);	
			КонецЕсли;
		Исключение		
			Прервать;
		КонецПопытки;		
	КонецЦикла;

	Тело = СоединитьДвоичныеДанные(ДвоичныеДанныеТела);

КонецПроцедуры

Процедура ПодготовитьЗаголовки(ДвоичныеДанныеЗаголовков)

	ЗаголовкиСтрокой = ПолучитьСтрокуИзДвоичныхДанных(ДвоичныеДанныеЗаголовков);
	ЗаголовкиМассивом = СтроковыеФункции.РазложитьСтрокуВМассивПодстрок(ЗаголовкиСтрокой, Символы.ПС);

	// Обработка данных
	Индекс = 0;
	Пока Индекс <> ЗаголовкиМассивом.Количество() Цикл
		
		ТекстЭлемента = ЗаголовкиМассивом[Индекс];
		// Обрабатываем основные данные запроса - тип, адрес, параметры url и версию протокола
		Если Индекс = 0 Тогда
			ОсновныеДанные = СтроковыеФункции.РазложитьСтрокуВМассивПодстрок(ЗаголовкиМассивом[0], " ");	
			ТипЗапроса = ОсновныеДанные[0];
			ПолныйАдрес = РаскодироватьСтроку(ОсновныеДанные[1], СпособКодированияСтроки.КодировкаURL);
			Адрес = РаскодироватьСтроку(ОсновныеДанные[1], СпособКодированияСтроки.КодировкаURL);
			ВерсияHTTP = ОсновныеДанные[2];
			ПоложениеНачалаПараметров = СтрНайти(ПолныйАдрес, "?");
			Если ПоложениеНачалаПараметров = 0 Тогда
				Индекс = Индекс + 1;
				Продолжить;	
			Иначе
				Адрес = Лев(ПолныйАдрес, ПоложениеНачалаПараметров - 1);		
			КонецЕсли;
			// Обработка параметров запроса
			ПараметрыЗапросаСтрокой = Прав(ПолныйАдрес, СтрДлина(ПолныйАдрес) - ПоложениеНачалаПараметров);
			МассивПараметровСтрокой = СтроковыеФункции.РазложитьСтрокуВМассивПодстрок(ПараметрыЗапросаСтрокой, "&");
			Для каждого Элемент Из МассивПараметровСтрокой Цикл
				ДанныеПараметра = СтроковыеФункции.РазложитьСтрокуВМассивПодстрок(Элемент, "=");	
				Ключ = ДанныеПараметра[0];
				Значение = СокрЛП(ДанныеПараметра[1]);		
				ПараметрыЗапроса.Вставить(Ключ, Значение);		
			КонецЦикла;		
		// Для всех остальных данных идёт разбор как заголовка
		Иначе
			ДанныеЗаголовка = СтроковыеФункции.РазложитьСтрокуВМассивПодстрок(ТекстЭлемента, ":");	
			Если ЗначениеЗаполнено(ДанныеЗаголовка) Тогда
				Ключ = ДанныеЗаголовка[0];
				Значение = СокрЛП(ДанныеЗаголовка[1]);
				Заголовки.Вставить(Ключ, Значение);
			КонецЕсли;
		КонецЕсли;
		
		Индекс = Индекс + 1;

	КонецЦикла;

КонецПроцедуры

#КонецОбласти

Функция РазделитьДвоичныеДанныеРазделителем(ДвоичныеДанные, Разделитель) Экспорт
	БайтыРазделителя = ПолучитьМассивБайт(Разделитель);
	ТекущийПорядокБайт = Новый Массив(БайтыРазделителя.Количество());
	Лево = Неопределено;
	Право = Неопределено;
	Чтение = Новый ЧтениеДанных(ДвоичныеДанные);

	Пока не Чтение.ЧтениеЗавершено Цикл
		ТекБайт = Чтение.Прочитать(1).ПолучитьДвоичныеДанные();
		ДобавитьВМассивСоСмещением(ТекущийПорядокБайт, ТекБайт);

		Если МассивыРавны(БайтыРазделителя, ТекущийПорядокБайт) Тогда
			Право = Чтение.Прочитать().ПолучитьДвоичныеДанные();
			Чтение.Закрыть();
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Чтение = Новый ЧтениеДанных(ДвоичныеДанные);

	Если Право = Неопределено или Право.Размер() = 0 Тогда
		Лево = Чтение.Прочитать().ПолучитьДвоичныеДанные();
	Иначе
		ЧитатьПо = ДвоичныеДанные.Размер() - Разделитель.Размер() - Право.Размер();
		Лево = Чтение.Прочитать(ЧитатьПо).ПолучитьДвоичныеДанные();
	КонецЕсли;

	Возврат Новый Структура("Лево, Право", Лево, Право);

КонецФункции

Функция МассивыРавны(Массив1, Массив2) Экспорт

	Если не Массив1.Количество() = Массив2.Количество() Тогда
		Возврат Ложь;
	Иначе
		Для сч = 0 По Массив1.ВГраница() Цикл
			Если Не Массив1[сч] = Массив2[сч] Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

	Возврат Истина;
	
КонецФункции

Процедура ДобавитьВМассивСоСмещением(Массив, ДобавляемыйЭлемент) Экспорт
	
	Если Массив.Количество() = 1 Тогда
		Массив[0] = ДобавляемыйЭлемент;
		Возврат;
	ИначеЕсли Массив.Количество() = 0 Тогда
		ВызватьИсключение "Пустой массив для смещения";
	КонецЕсли;

	Для сч = 0 по Массив.ВГраница() - 1 Цикл
		Массив[сч] = Массив[сч + 1];
	КонецЦикла;

	Массив[Массив.ВГраница()] = ДобавляемыйЭлемент;

КонецПроцедуры

Функция ПолучитьМассивБайт(ДвоичныеДанные) Экспорт

	Возврат РазделитьДвоичныеДанные(ДвоичныеДанные, 1);

КонецФункции